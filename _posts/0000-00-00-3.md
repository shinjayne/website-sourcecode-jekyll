---
layout : post
title : "Scala ì˜ Type Class ì½”ë“œë¡œ ì‚´í´ë³´ê¸° 1"
date : 2017-06-29 00:45:40 +0900
categories : language
tags : scala typeclass

post_id : 3
permalink : "/post/3"
imageurl : "/asset/media/image/post/3"
mainpic :  "/asset/media/image/post/3/scala-icon.png"
---

ì´ë²ˆ ê¸€ì—ì„œëŠ” **scala ì˜ Type class** ì— ëŒ€í•´ì„œ ì½”ë“œì™€ í•¨ê»˜ ì•Œì•„ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

**Type class** ë¥¼ ì´ìš©í•˜ë©´

ê¸°ì¡´ì˜ object oriented programming ì—ì„œ ì‚¬ìš©í•˜ë˜

**ìƒì†ì´ë‚˜ ê°ì²´, í´ë˜ìŠ¤ì˜ ê°œë… ì—†ì´ë„** ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

(ê°œì¸ì ì¸ ì†Œê°ìœ¼ë¡œëŠ”, Object Oriented Programming ì˜ ì†Œì¤‘í•¨ì„ ëŠë¼ê²Œ í•´ì£¼ëŠ” ê³µë¶€ì˜€ìŠµë‹ˆë‹¤...)


<br/>
<br/>
<br/>
# 1. Type Class ì˜ êµ¬ì„±
<br/>
<br/>
<br/>
1. type class ë³¸ì²´

2. type class ì˜ instance (customizing)

3. type class ì˜ interface (í•¨ìˆ˜ ì‚¬ìš©)


Type class ëŠ” í¬ê²Œ ìœ„ì™€ê°™ì€  3ê°€ì§€ êµ¬ì„±ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤ .  
<hr/>

**Type class ë³¸ì²´**ëŠ” `abstract class` ë˜ëŠ” `trait`ë¡œ ë§Œë“­ë‹ˆë‹¤.

ìì„¸í•œ ë©”ì„œë“œì˜ êµ¬í˜„ì€ ìƒëµí•˜ê³ , ê³µí†µëœ ë™ì‘ë§Œ ê¸°ìˆ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
<hr/>

**Type class ì˜ instance** ëŠ” Type class ì˜ ë³¸ì²´ì— íŠ¹ì • Type ì„ ëŒ€ì…í•˜ì—¬ êµ¬ì²´í™”ì‹œì¼°ë‹¤ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

Type class ì˜ ì¸í„°í˜ì´ìŠ¤(interface) ì— íŠ¹ì • Type ì´ ë“¤ì–´ì™”ì„ ë•Œ ì–´ë–¤ ë™ì‘ì„ í•  ê²ƒì¸ì§€ êµ¬ì²´ì ìœ¼ë¡œ Type Class ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ í‘œí˜„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`implicit def`, ë˜ëŠ” `implicit val` ë¡œ ë§ì´ í‘œí˜„í•©ë‹ˆë‹¤. ìì„¸í•œ ì˜ˆëŠ” ì•„ë˜ì„œ ë‹¤ë£¨ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.
<hr/>

**Type Class ì˜ interface**ëŠ” ë‘ ê°€ì§€ íŒŒë¼ë©”í„°(ì¸ì)ë¥¼ ë°›ìŠµë‹ˆë‹¤.

í•˜ë‚˜ëŠ” ì‹¤ì œ í•¨ìˆ˜ì—ì„œ ë‹¤ë£° ë°ì´í„°ì´ê³ , í•˜ë‚˜ëŠ” ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë™ì‘ì´ ê¸°ìˆ ë˜ì–´ìˆëŠ” Type class ì˜ instance ì…ë‹ˆë‹¤.


<br/>
<br/>
<br/>
# 2. Type Class ê°œìš”
<br/>
<br/>
<br/>

ê¸°ë³¸ì ìœ¼ë¡œ type class ëŠ” type ì„ parameterë¡œ ë°›ëŠ” class ì…ë‹ˆë‹¤.

ì´ì œ ì´ ì•„ë˜ë¶€í„°ëŠ” ì‹¤ì œ ìŠ¤ì¹¼ë¼ ì½”ë“œë¥¼ í†µí•´ì„œ ì—¬ëŸ¬ê°€ì§€ Type Class ì™€ ê·¸ì˜ ì¸ìŠ¤í„´ìŠ¤, ì¸í„°í˜ì´ìŠ¤ë“¤ì„ êµ¬í˜„í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

<br/>
<br/>
<br/>
# 3. í•˜ë‚˜ì˜ type parameter ë¥¼ ë°›ëŠ” Type class
<br/>
<br/>
<br/>

### part1 : type class ì˜ ë³¸ì²´
<hr/>
Ord[A] ëŠ” type A ì˜ ë¬´ì–¸ê°€ë¥¼ í¬ê¸°ë¹„êµí•˜ëŠ” ê¸°ëŠ¥ì„ ê°€ì§„ type class ì…ë‹ˆë‹¤.

Type Class ëŠ” ê°„ë‹¨íˆ `abstract class` ë˜ëŠ” `traits`ë¥¼ í†µí•´ êµ¬í˜„í•©ë‹ˆë‹¤.

ë©”ì„œë“œëŠ” ì •ì˜í•˜ì§€ë§Œ ì •í™•í•œ ë™ì‘ì€ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ êµ¬í˜„í•©ë‹ˆë‹¤.


```scala
abstract class Ord[A]{
  def cmp(me : A, you : A) : Int  // instnace ì—ì„œ êµ¬í˜„ë  ê²ƒì…ë‹ˆë‹¤.

  //Aì˜ type ê³¼ ê´€ê³„ ì—†ëŠ” ê³µí†µëœ ë©”ì„œë“œë“¤ì€ ë¯¸ë¦¬ ì‘ì„±í•´ë†“ê¸°ë„ í•©ë‹ˆë‹¤.   
  def ===(me : A, you : A) : Boolean = cmp(me, you) == 0
  def <(me : A, you : A) : Boolean = cmp(me, you) < 0
  def >(me : A, you : A) : Boolean = cmp(me, you) > 0
  def <=(me : A, you : A) : Boolean = cmp(me, you) <= 0
  def >=(me : A, you : A) : Boolean = cmp(me, you) >= 0
}

```




    defined [32mclass[39m [36mOrd[39m



### part2 : type class ì˜ instance (customize)
<hr/>
Ord[A] ì˜ type parameter A ì— ë‹¤ì–‘í•œ type ì„ ì§‘ì–´ë„£ìŒìœ¼ë¡œì¨ ê°ê°ì˜ instance ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

type parameter ì˜ instance ëŠ”
`implicit val` ë˜ëŠ” `implicit def` ë¥¼ í†µí•´ êµ¬í˜„í•©ë‹ˆë‹¤.

**(`implicit def`ëŠ” ë³´í†µ ìƒì„±í•  instanceì— parameter type ì„ í•œë²ˆ ë” ì£¼ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. )**

ì˜ ê°ì´ ì•ˆì˜¤ì‹ ë‹¤ë©´, ë°‘ì— ì½”ë“œì—ì„œ í•œë²ˆ ë” ì–¸ê¸‰ë  ê²ƒì…ë‹ˆë‹¤. ê·¸ë•Œ ë‹¤ì‹œ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.

#### 1. Ord[Int] ì¸ìŠ¤í„´ìŠ¤

Int ë¼ëŠ” íƒ€ì…ì„ ë‹¤ë£° ìˆ˜ ìˆëŠ” Type class ì˜ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.

ì´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ëŠ” interfaceëŠ” Int íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```scala
// A = Int
implicit val intOrd : Ord[Int] = new Ord[Int]{  //Ord[A] ì˜ A ì— Intë¥¼ ëŒ€ì…í•˜ê³  new Ord[Int] ë¡œ ì´ˆê¸°í™”
  def cmp(me : Int , you : Int) : Int  = me - you
}
```
```scala
    cmd0.sc:1: not found: type Ord
    implicit val intOrd : Ord[Int] = new Ord[Int]{  //Ord[A] ì˜ A ì— Intë¥¼ ëŒ€ì…í•˜ê³  new Ord[Int] ë¡œ ì´ˆê¸°í™”
                          ^cmd0.sc:1: not found: type Ord
    implicit val intOrd : Ord[Int] = new Ord[Int]{  //Ord[A] ì˜ A ì— Intë¥¼ ëŒ€ì…í•˜ê³  new Ord[Int] ë¡œ ì´ˆê¸°í™”
                                         ^


    Compilation Failed
```

#### 2. Ord[Double] ì¸ìŠ¤í„´ìŠ¤

ë§ˆì°¬ê°€ì§€ê³  Double ì´ë¼ëŠ” íƒ€ì…ì„ ë‹¤ë£° ìˆ˜ ìˆëŠ” Type class ì˜ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.

ì´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ëŠ” interfaceëŠ” Double íƒ€ì…ì˜ ë°ì´í„°ë¥¼ ì¡°ì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```scala
// A = Double
implicit val doubleOrd : Ord[Double] = new Ord[Double]{
  def cmp(me : Double, you : Double) : Int = (me - you).toInt
}

```




    [36mdoubleOrd[39m: [32mOrd[39m[[32mDouble[39m] = $sess.cmd2Wrapper$Helper$$anon$1@3368bc6f



#### 3. Ord[ (X,Y) ] ì¸ìŠ¤í„´ìŠ¤   
ì—¬ê¸°ì—ì„  íŠ¹ë³„í•˜ê²Œ implicit instance ì•ˆì— ì¸ìë¡œ ë‹¤ì‹œí•œë²ˆ implicit parameterë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤.

(X,Y) í˜•ì‹ì˜ type ì„ ë‹¤ë£° ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” Type class ì˜ ì¸ìŠ¤í„´ìŠ¤ì´ê³ ,

ì´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°›ëŠ” interfaceëŠ” ëª¨ë‘ (X,Y) í˜•ì‹ì˜ type ì˜ ë°ì´í„°ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**type class interface + instance** ì˜ í˜¼ì¢…ì´ë¼ê³  ìƒê°í•˜ë©´ ì¢‹ê² ìŠµë‹ˆë‹¤.
(ì•„ë˜ interface ë¶€ë¶„ì„ ë³´ì‹œê³  ë‹¤ì‹œ ë³´ì‹œëŠ”ê²Œ ì´í•´ì— ë„ì›€ ë©ë‹ˆë‹¤. ì¡°ê¸ˆ ì–´ë µìŠµë‹ˆë‹¤.)


```scala
// A = (X,Y)
implicit def twoOrd[X,Y](implicit ordX : Ord[X], ordY : Ord[Y])  : Ord[(X,Y)] = new Ord[(X,Y)]{
  def cmp(me : (X,Y), you : (X,Y)) : Int = {
    val c1 = ordX.cmp(me._1, you._1)
    if(c1 != 0) c1
    else ordY.cmp(me._2 , you._2)
  }
}
```




    defined [32mfunction[39m [36mtwoOrd[39m



### part3 : type class interface (ì‚¬ìš©)
<hr/>

type class Ord[X] ì˜ interface ì—ëŠ” ë‘ê°œì˜ ì…êµ¬ê°€ ìˆìŠµë‹ˆë‹¤.

1. type X ì¸ ë°ì´í„° parameter ë“¤ì„ ë°›ëŠ” ì…êµ¬
2. Ord[X] ì˜ instance ë¥¼ implicit parameter ë¡œ ë°›ëŠ” ì…êµ¬

***1ë²ˆ ì…êµ¬ì—ì„œ ë°›ì€ data ë“¤ì„ , 2ë²ˆ ì…êµ¬ì—ì„œ ë°›ì€ type class instance ì˜ ê·œì¹™ì„ ì´ìš©í•´ ì²˜ë¦¬í•©ë‹ˆë‹¤. ***

ì—¬ê¸°ì„œ implicit parameter ì˜ ì…êµ¬ëŠ”, scala ì˜ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ìë™ìœ¼ë¡œ ì½”ë“œ ë‚´ì˜ implicit val / implicit def ë¡œ êµ¬í˜„ëœ Cls[X] ì˜ instance ë¥¼ ì°¾ì•„ ì—°ê²°í•©ë‹ˆë‹¤.

*** ì¦‰, 1ë²ˆ ì…êµ¬ëŠ” ë„£ì–´ì£¼ì–´ì•¼í•˜ì§€ë§Œ, 2ë²ˆ ì…êµ¬ëŠ” ì¸ìŠ¤í„´ìŠ¤ë“¤ë§Œ ë§Œë“¤ì–´ ë†“ì•˜ë‹¤ë©´ ìë™ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. ***


```scala
def max3[A](a : A, b : A, c: A)(implicit ord : Ord[A]) : A =
  if (ord.<=(a,b))  {if (ord.<=(b,c)) c else b}
  else              {if (ord.<=(a,c)) c else a }


```




    defined [32mfunction[39m [36mmax3[39m



### result
<hr/>


```scala
max3[Int](1,2,3)  // ord = intOrd ì¸ìŠ¤í„´ìŠ¤ ìë™ ì‚¬ìš©ë¨
max3[Double](1.1, 2.2, 3.3) // ord = doubleOrd ì¸ìŠ¤í„´ìŠ¤ ìë™ ì‚¬ìš©ë¨
```




    [36mres5_0[39m: [32mInt[39m = [32m3[39m
    [36mres5_1[39m: [32mDouble[39m = [32m3.3[39m



<br/>
<br/>
<br/>
# 4. ë‘ê°œ ì˜ type parameter ë¥¼ ë°›ëŠ” Type class
<br/>
<br/>
<br/>

ê°™ì€ ë°©ì‹ìœ¼ë¡œ, ì´ë²ˆì—” ë‘ê°œì˜ type parameter ë¥¼ ë°›ëŠ” type class ë¥¼ ë³´ê² ìŠµë‹ˆë‹¤.

### part1 : type class ì˜ ë³¸ì²´
<hr/>
Iter[I,A] ëŠ” type A ë¥¼ ì €ì¥í•˜ê³ ìˆëŠ” type I ì—ì„œ , Aë¥¼ ì¡°íšŒí•˜ê±°ë‚˜ ë‹¤ìŒ I ë¡œ ë„˜ì–´ê°€ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ìë©´,

A ê°€ Int ì´ë©´ I ëŠ” ì´ë¥¼ ì €ì¥í•˜ëŠ” List[Int]ê°€ ë  ê²ƒì´ê³ 

A ê°€ String ì´ë©´ IëŠ” ì´ë¥¼ ì €ì¥í•˜ëŠ” List[String] ì´ ë  ê²ƒì…ë‹ˆë‹¤.  



```scala
abstract class Iter[I, A]{    
  def getValue(i : I) : Option[A]  //ë©”ì„œë“œì˜ ë””í…Œì¼ì€ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ êµ¬í˜„í•©ë‹ˆë‹¤.
  def getNext(i : I) : I
}

```




    defined [32mclass[39m [36mIter[39m



<br/>
### part2 : type class ì˜ instance (customize)
<hr/>
Iter[I, A] ì˜ parameter I, A ì— ë‹¤ì–‘í•œ type ì„ ì§‘ì–´ë„£ìŒìœ¼ë¡œì¨ ê°ê°ì˜ instance ë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

ë‹¤ì‹œí•œë²ˆ..<br/>
**(`implicit def`ëŠ” ë³´í†µ ìƒì„±í•  instanceì— parameter type ì„ í•œë²ˆ ë” ì£¼ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. )**

<br/>
#### 1. Iter[Int, Int] ì¸ìŠ¤í„´ìŠ¤


```scala
// I = Int, A = Int

// Int ë¼ëŠ” ì €ì¥ êµ¬ì¡°(I) ì•ˆì—ì„œ Int ë°ì´í„°(A)ë¥¼ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
implicit val intIter : Iter[Int, Int] = new Iter[Int, Int]{
  def getValue(i : Int) = if (i>0) Some(i) else None  
  def getNext(i : Int) = if(i-1 > 0 ) i-1 else 0
}
```




    [36mintIter[39m: [32mIter[39m[[32mInt[39m, [32mInt[39m] = $sess.cmd7Wrapper$Helper$$anon$1@5a79ff31



<br/>
#### 2. Iter[ List[X],  X ] ì¸ìŠ¤í„´ìŠ¤

ì´ ì¸ìŠ¤í„´ìŠ¤ì˜ ë…íŠ¹í•œ ì ì€, ì¸ìŠ¤í„´ìŠ¤ì˜ ì™„ì„±ì„ interface ë¡œ  ë– ë„˜ê²¼ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.

XëŠ” ê²°êµ­ ì´ ì¸ìŠ¤í„´ìŠ¤ê°€ ì‚¬ìš©ë˜ëŠ” interface ì—ì„œ ê²°ì •ë©ë‹ˆë‹¤.

ì¦‰ interfaceì—ì„œ Xë¥¼ Int ë¡œ ì£¼ë©´ Iter[List[Int], Int] ê°€ ë˜ê³ 

ë‹¤ë¥¸ ê°’ìœ¼ë¡œ ì£¼ë©´ ë‹¬ë¼ì§‘ë‹ˆë‹¤.


```scala
// I = List[X], A = X

//List ë¼ëŠ” ì €ì¥êµ¬ì¡° (I) ì•ˆì—ì„œ X íƒ€ì…ì˜ ë°ì´í„°(A) ë¥¼ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
implicit def listIter[X] : Iter[List[X], X] = new Iter[List[X], X]{
  def getValue(i : List[X]) = i.headOption
  def getNext(i  : List[X]) = i.tail
}
```




    defined [32mfunction[39m [36mlistIter[39m



<br/>
### part3 : type class interface (ì‚¬ìš©)
<hr/>




```scala
// listIter ì˜ Xë¥¼ ì¸ìŠ¤í„´ìŠ¤ íŒŒë¼ë©”í„°ì—ì„œ Intë¡œ ê³ ì •í•´ë†“ì•˜ìŠµë‹ˆë‹¤.
def sumElements[I](xs : I)(implicit proxy : Iter[I, Int]) : Int = proxy.getValue(xs) match{
  case None => 0
  case Some(n) => n + sumElements(proxy.getNext(xs))
}


// listIter ì˜ XëŠ” xs(I) ì˜ íƒ€ì…ì— ë”°ë¼ ê²°ì •ë©ë‹ˆë‹¤. I ê°€ List[Int] ì´ë©´, A ë„ Int ê°€ ë©ë‹ˆë‹¤.
def printElements[I](xs : I)(implicit proxy : Iter[I, A]) :Unit = proxy.getValue(xs) match{
  case None =>
  case Some(n) => {println(n) ; printElements(proxy.getNext(xs))}
}
```




    defined [32mfunction[39m [36msumElements[39m
    defined [32mfunction[39m [36mprintElements[39m



<br/>
### result
<hr/>


```scala
printElements[List[Int]](List(3,4,5,6))
printElements[Int](10)
```

    3
    4
    5
    6
    10
    9
    8
    7
    6
    5
    4
    3
    2
    1


<br/>
<br/>
<br/>
# 5. ì¢€ ë” ë³µì¡í•œ ë¬¸ì œë“¤
<br/>
<br/>
<br/>
### ì¬ë£Œ
<hr/>


```scala
//ì¬ë£Œ
sealed abstract class MyTree[A]
case class Empty[A]() extends MyTree[A]
case class Node[A](value : A, left : MyTree[A], right : MyTree[A]) extends MyTree[A]

```




    defined [32mclass[39m [36mMyTree[39m
    defined [32mclass[39m [36mEmpty[39m
    defined [32mclass[39m [36mNode[39m



<br/>
### part1 : type class ë³¸ì²´
<hr/>
ìˆœí™˜ì ì´ì§€ ì•Šì€ type R ì˜ ë¬´ì–¸ê°€ë¥¼ ìˆœí™˜ì ìœ¼ë¡œ ë§Œë“¤ì–´ì¤€ë‹¤.

iter()ëŠ” ìˆœí™˜ì ì´ì§€ ì•Šì€ type R ì˜ ë¬´ì–¸ê°€ë¥¼ ìˆœí™˜ì ì¸ I ë¡œ ë°”ê¾¸ê³ , IëŠ” Aë“¤ì„ í¬í•¨í•œë‹¤.


```scala
abstract class Iterable[R, I ,A] {
  def iter(a: R) : I
  def iterProxy : Iter[I,A]
}
```



```scala
defined [32mclass[39m [36mIterable[39m
```


<br/>
### part2 : type class ì˜ instance (customize)
***
<br/>
#### Iterable[ MyTree[X] , List[X],  X ] ì¸ìŠ¤í„´ìŠ¤            (<- X ìœ ë™ì  )


```scala
implicit def treeIterable[X](implicit proxy : Iter[List[X], X]) : Iterable[MyTree[X], List[X], X] = new Iterable[MyTree[X], List[X], X]{
  def iter(a : MyTree[X]) : List[X] = a match{
    case Empty() =>  Nil
    case Node(v, left, right) => v :: (iter(left) ++ iter(right))
  }
  def iterProxy : Iter[List[X], X] =  proxy
}
```




    defined [32mfunction[39m [36mtreeIterable[39m



<br/>
### part3 : type class ì˜ interface (ì‚¬ìš©)
***


```scala
def sumElements2[R, I](xs : R)(implicit proxy : Iterable[R, I ,Int]) = sumElements(proxy.iter(xs))(proxy.iterProxy)

def printElements2[R, I](xs : R)(implicit proxy : Iterable[R, I, Int]) = printElements(proxy.iter(xs))(proxy.iterProxy)
```




    defined [32mfunction[39m [36msumElements2[39m
    defined [32mfunction[39m [36mprintElements2[39m



<br/>
### result


```scala
val tree : MyTree[Int] = Node(10, Node(9, Empty(), Empty()), Node(8, Empty(), Empty()))

sumElements2[MyTree[Int], List[Int]](tree)
```




    [36mtree[39m: [32mMyTree[39m[[32mInt[39m] = Node(10,Node(9,Empty(),Empty()),Node(8,Empty(),Empty()))
    [36mres15_1[39m: [32mInt[39m = [32m27[39m



<br/>
<br/>
<br/>
# 6. Higher-kind Type classes
<br/>
<br/>
<br/>
Higher-kind ëŠ” type ë“¤ì„ ë‹¤ì‹œ ìƒìœ„ì˜ í•˜ë‚˜ì˜ ê°œë…ìœ¼ë¡œ ë¬¶ëŠ”, ìƒìœ„ ì¹´í…Œê³ ë¦¬ë¼ê³  í•  ìˆ˜ ìˆê³ , ë³€ì—­ì€ "ìƒë¥˜" ë¡œ í•œë‹¤.

ì•„ë˜ ë§í¬ë¥¼ ì°¸ê³ í•˜ë©´ ì¢‹ë‹¤.
> twitter ì˜ scalaschool : scalaì˜ ìƒë¥˜ íƒ€ì…

> https://twitter.github.io/scala_school/ko/advanced-types.html#higher

### ì¬ë£Œ
<hr/>


```scala
import scala.language.higherKinds
```




    [32mimport [39m[36mscala.language.higherKinds[39m



higher kind ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ scala ì—ì„œ ìœ„ì²˜ëŸ¼ higerKinds íŒ¨í‚¤ì§€ë¥¼ import í•´ì¤˜ì•¼í•œë‹¤.

### part1 : type class ë³¸ì²´



```scala
abstract class Iter2[I[_]]{
    def getValue[A](a : I[A]) : Option[A]
    def getNext[A](a : I[A]) : I[A]
}
```




    defined [32mclass[39m [36mIter2[39m



### part2 : type class ì˜ instance (customize)
***
`Iter2[I[_]]` ë¥¼ ì¼ì¢…ì˜ ìµëª…í•¨ìˆ˜ ì²˜ëŸ¼ ìƒê°í•˜ê³  , ë¹ˆì¹¸ì•ˆì— ë“¤ì–´ì˜¬ ì¸ìíƒ€ì…ì€ ë‚˜ì¤‘ì— ë°›ëŠ” ê²ƒìœ¼ë¡œ ë³´ë¥˜í•˜ê³  ë‚˜ë¨¸ì§€ë¥¼ êµ¬í˜„í•œë‹¤.



```scala
implicit val listIter2 : Iter2[List] = new Iter2[List]{
    def getValue[A](a : List[A]) = a.headOption
    def getNext[A](a : List[A]) = a.tail
}
```




    [36mlistIter2[39m: [32mIter2[39m[[32mList[39m] = $sess.cmd18Wrapper$Helper$$anon$1@1188d429



### part3 : type class ì˜ interface (ì‚¬ìš©)
***


```scala
// Int ë¥¼ ë‹´ëŠ” higerkind I ì— ëŒ€í•´ì„œë§Œ ë™ì‘í•œë‹¤.
def sumElements3[I[_]](xs : I[Int])(implicit itr2 : Iter2[I]) : Int = {
    itr2.getValue(xs) match {
        case None => 0
        case Some(n) => n + sumElements3(itr2.getNext(xs))
    }
}

// higerkind I ì— ë‹´ê¸´ type Xì— êµ¬ì• ë¥¼ ë°›ì§€ ì•ŠëŠ”ë‹¤.
def printElements3[I[_],X](xs : I[X])(implicit itr2 : Iter2[I]) : Unit = {
    itr2.getValue(xs) match {
        case None =>
        case Some(n) => {println(n) ; printElements3(itr2.getNext(xs))}
    }
}
```




    defined [32mfunction[39m [36msumElements3[39m
    defined [32mfunction[39m [36mprintElements3[39m



### result
***


```scala
val lst = List(4, 5, 10 ,8, 9)

sumElements3(xs = lst)

// ê³¼ì •1.    lst ê°€ ë“¤ì–´ê°€ë©´ì„œ I = List íƒ€ì…ì¸ì ì „ë‹¬ ;
// ê³¼ì •2.    itr2 : Iter2[List] = listIter2   ìë™ìœ¼ë¡œ ì±„ì›Œì§ (implicit ë¼ë¦¬ì˜ ì—°ë™)

printElements3(xs = lst)
```

    4
    5
    10
    8
    9





    [36mlst[39m: [32mList[39m[[32mInt[39m] = [33mList[39m([32m4[39m, [32m5[39m, [32m10[39m, [32m8[39m, [32m9[39m)
    [36mres21_1[39m: [32mInt[39m = [32m36[39m



<br/>
<br/>
<br/>
# 7. Higher-kind Type classes + ì¢€ ë” ì–´ë ¤ìš´ ë¬¸ì œë“¤
<br/>
<br/>
<br/>
ìˆœí™˜ê°€ëŠ¥í•˜ì§€ ì•Šì€ íƒ€ì… R ì„ ìˆœí™˜ ê°€ëŠ¥í•œ íƒ€ì… I ìœ¼ë¡œ ë°”ê¿”ì£¼ëŠ” ë™ì‘ê³¼ (`def iter : I`),

ê·¸ ìˆœí™˜ê°€ëŠ¥í•œ íƒ€ì… Iì— ëŒ€í•œ ìˆœí™˜ë™ì‘(`type class Iter2[I]`) ì„ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ë™ì‘(`def iterProxy : Iter2[I]`)   

ìœ¼ë¡œ êµ¬ì„±ëœ ìƒˆë¡œìš´ `type class Iterable2[R[_], I[_]]` ë¥¼ ë§Œë“¤ì–´ë³´ì.

### ì¬ë£Œ
<hr/>


```scala
import scala.language.higherKinds
```




    [32mimport [39m[36mscala.language.higherKinds[39m



ì•„ë˜ëŠ” ì˜ˆì œì— ì‚¬ìš©ë  MyTree ë¼ëŠ” ë°ì´í„°íƒ€ì…ì´ë‹¤.


```scala
//ì¬ë£Œ
sealed abstract class MyTree[A]
case class Empty[A]() extends MyTree[A]
case class Node[A](value : A, left : MyTree[A], right : MyTree[A]) extends MyTree[A]

```




    [32mimport [39m[36mscala.language.higherKinds

    [39m
    defined [32mclass[39m [36mMyTree[39m
    defined [32mclass[39m [36mEmpty[39m
    defined [32mclass[39m [36mNode[39m



</br>
### part1 : type class ë³¸ì²´
***


```scala
abstract class Iterable2[R[_], I[_]]{
    def iter[A](a : R[A]) : I[A]
    def iterProxy : Iter2[I]
}
```




    defined [32mclass[39m [36mIterable2[39m



<br/>
### part2 : type class ì˜ instance (customize)
***



```scala
implicit def treeIterable2(implicit proxy : Iter2[List]) : Iterable2[MyTree, List] = new Iterable2[MyTree, List]{
    def iter[A](a : MyTree[A]) : List[A] = a match {
        case Empty() => Nil
        case Node(v, left, right) => v :: (iter(left) ++ iter(right))
    }
    def iterProxy : Iter2[List]  =  proxy
}
```




    defined [32mfunction[39m [36mtreeIterable2[39m



TIP ::  ìœ„ì˜ ì½”ë“œëŠ” ì•„ë˜ì™€ê°™ì´ë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.


```scala
/**
implicit def treeIterable2: Iterable2[MyTree, List] = new Iterable2[MyTree, List]{
    def iter[A](a : MyTree[A]) : List[A] = a match {
        case Empty() => Nil
        case Node(v, left, right) => v :: (iter(left) ++ iter(right))
    }
    def iterProxy : Iter2[List]  =  implicitly[Iter2[List]] // type ì£¼ì–´ì§„ ì±„ë¡œ ì—°ë™í•˜ê¸°  
}
**/
```

<br/>
### part3 : type class ì˜ interface (ì‚¬ìš©)
***


```scala
def sumElements4[R[_],I[_]](xs : R[Int])(implicit proxy : Iterable2[R, I]) = sumElements3(proxy.iter(xs))(proxy.iterProxy)

//1. xs ì— ì¸ìê°€ ì „ë‹¬ëœë‹¤. Rê³¼ _ê°€ ê²°ì •ëœë‹¤.
//2. ê²°ì •ëœ Rê³¼ _ ë¥¼ í™•ì¸í•œ implicit ê°€ proxy ë¥¼ ê²°ì •í•œë‹¤. Iê°€ ê²°ì •ëœë‹¤.


def printElements4[R[X], I[X], X](xs : R[X])(implicit proxy : Iterable2[R,I]) = printElements3(proxy.iter(xs))(proxy.iterProxy)
```




    defined [32mfunction[39m [36msumElements4[39m
    defined [32mfunction[39m [36mprintElements4[39m



### result
***


```scala
val t2 : MyTree[Int] = Node(3, Node(4, Node(5, Empty(), Empty()), Empty()), Empty())
```




    [36mt2[39m: [32mMyTree[39m[[32mInt[39m] = Node(3,Node(4,Node(5,Empty(),Empty()),Empty()),Empty())




```scala
sumElements4(t2)
printElements4(t2)
```

    3
    4
    5





    [36mres28_0[39m: [32mInt[39m = [32m12[39m



<br/>
<br/>
<br/>
# 8. Higher-kind Type classes + Functor Specification
<br/>
<br/>
<br/>


### ì¬ë£Œ
<hr/>


```scala
import scala.language.higherKinds
```




    [32mimport [39m[36mscala.language.higherKinds[39m




```scala
//ì¬ë£Œ
sealed abstract class MyTree[A]
case class Empty[A]() extends MyTree[A]
case class Node[A](value : A, left : MyTree[A], right : MyTree[A]) extends MyTree[A]

```




    defined [32mclass[39m [36mMyTree[39m
    defined [32mclass[39m [36mEmpty[39m
    defined [32mclass[39m [36mNode[39m



</br>
### part1 : type class ë³¸ì²´
***


```scala
trait Functor[F[_]] {
    def map[A, B](f : A=>B)(x : F[A]) : F[B]
}
```




    defined [32mtrait[39m [36mFunctor[39m



<br/>
### part2 : type class ì˜ instance (customize)
***



```scala
implicit val ListFunctor : Functor[List] = new Functor[List]{
    def map[A,B](f : A=>B)(x : List[A]) : List[B] = x.map(f)
}

implicit val TreeFunctor : Functor[MyTree] = new Functor[MyTree]{
    def map[A,B](f : A=>B)(x : MyTree[A]) : MyTree[B] = x match{
        case Empty() => Empty()
        case Node(v, left, right) => Node(f(v), map(f)(left), map(f)(right))
    }
}
```




    [36mListFunctor[39m: [32mFunctor[39m[[32mList[39m] = $sess.cmd33Wrapper$Helper$$anon$1@3bbdd7c8
    [36mTreeFunctor[39m: [32mFunctor[39m[[32mMyTree[39m] = $sess.cmd33Wrapper$Helper$$anon$2@6f83087e



<br/>
### part3 : type class ì˜ interface (ì‚¬ìš©)
***


```scala
def compose[F[_],X,Y,Z](g : Y=>Z)(f : X=>Y)(xs : F[X])(implicit proxy : Functor[F]) : F[Z] ={
    proxy.map(g)(proxy.map(f)(xs))
}
```




    defined [32mfunction[39m [36mcompose[39m



### result
***


```scala

```




    [36mt2[39m: [32mMyTree[39m[[32mInt[39m] = Node(3,Node(4,Node(5,Empty(),Empty()),Empty()),Empty())




```scala

```

    3
    4
    5





    [36mres28_0[39m: [32mInt[39m = [32m12[39m
